<!--
  Copyright (C) 2022, Desobry David
  SPDX-License-Identifier: AGPL-3.0-or-later
  See <https://www.gnu.org/licenses/>
-->
<!doctype html>
<html>
  <head>
		<title>HTML Quad Mesher</title>
		<style>
			html,body {
				margin: 0;
  				padding: 0;
			}

			#loading-spinner {
			  position: fixed;
			  top: 50%;
			  left: 50%;
			  transform: translate(-50%, -50%);
			  z-index: 9999;
			  display: none;
			}
		
			.spinner {
			  width: 40px;
			  height: 40px;
			  margin: 0 auto;
			  border: 4px solid rgba(0, 0, 0, 0.2);
			  border-top-color: #3498db;
			  border-radius: 50%;
			  animation: spin 1s linear infinite;
			}
		
			@keyframes spin {
			  0% {
				transform: rotate(0deg);
			  }
			  100% {
				transform: rotate(360deg);
			  }
			}

			/* Tooltip container */
			.tooltip {
			position: fixed;
			top: 20px;
			left: 20px;
			display: inline-block;
			z-index: 1;
			}

			input[type="file"] {
			padding: 5px 10px;
			background-color: #3498db;
			color: white;
			border: none;
			border-radius: 3px;
			font-size: 1em;
			cursor: pointer;
			transition: background-color 0.3s ease, transform 0.3s ease;
			box-shadow: 0px 0px 8px rgba(0,0,0,0.2);
			width: 100%; /* Make the button take up the full width of the container */
			}

			input[type="file"]:hover {
			background-color: #2980b9;
			transform: scale(1.05);
			}

			/* Tooltip text */
			.tooltip .tooltiptext {
			visibility: hidden;
			background-color: #555;
			color: #fff;
			text-align: left; /* Align the text to the left */
			padding: 10px;
			border-radius: 6px;
			white-space: normal; /* Allow the text to wrap to new lines */

			/* Position the tooltip */
			position: absolute;
			z-index: 1;
			top: 130%; /* Adjust if necessary to place the tooltip below the button */
			left: 0;
			width: 100%; /* Make the tooltip text the same width as the button */

			/* Fade in tooltip */
			opacity: 0;
			transition: opacity 0.3s;
			}

			/* Tooltip arrow */
			.tooltip .tooltiptext::after {
			content: "";
			position: absolute;
			bottom: 100%; /* At the top of the tooltip */
			left: 50%;
			margin-left: -5px;
			border-width: 5px;
			border-style: solid;
			border-color: transparent transparent #555 transparent;
			}

			/* Show the tooltip text when you mouse over the tooltip container */
			.tooltip:hover .tooltiptext {
			visibility: visible;
			opacity: 1;
			}
		  </style>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<!--link type="text/css" rel="stylesheet" href="main.css"-->
	</head>
  <body>
    <!--default html file upload button-->
    <div class="tooltip">
		<input type="file" id="file-selector" accept=".obj,.mesh"/>
		<span class="tooltiptext">After the webpage is loaded, select a .obj or .mesh input file containing a triangular mesh fully connected and manifold</span>
	  </div>
	<div id="loading-spinner">
		<div class="spinner"></div>
	</div>
	<script>
		document.addEventListener("DOMContentLoaded", function() {
			const loadingSpinner = document.getElementById("loading-spinner");
			loadingSpinner.style.display = "none";
			window.addEventListener("load", function() {
				loadingSpinner.style.display = "none";
			});
		});
	</script>

    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
		{
			"imports": {
			"three": "https://unpkg.com/three@0.148.0/build/three.module.js",
      "lilgui" : "https://unpkg.com/three@0.148.0/examples/jsm/libs/lil-gui.module.min.js",
      "orbitcontrol" : "https://unpkg.com/three@0.148.0/examples/jsm/controls/OrbitControls.js"
			}
		}
		</script>
		<script type="module">

			// "obj": "https://unpkg.com/three/src/loaders/ObjectLoader.js"

import * as THREE from 'three';
import * as LILGUI from 'lilgui';
import * as ORBITCONTROL from 'orbitcontrol';
			
			//import { ObjectLoader } from 'obj';
			//import { OBJLoader } from './OBJLoader.js';

import {
	BufferGeometry,
	WireframeGeometry,
	FileLoader,
	Float32BufferAttribute,
	Group,
	LineBasicMaterial,
	LineSegments,
	Loader,
	Material,
	MeshPhongMaterial,
	Points,
	PointsMaterial,
	Color,
	Vector3
} from 'three';


const worker = new Worker("utils/wasm_worker.js");

worker.postMessage({command:"start"}); // trigger the worker to load WASM module
const loadingSpinner = document.getElementById("loading-spinner");
//loadingSpinner.style.display = "block";
// o object_name | g group_name
const _object_pattern = /^[og]\s*(.+)?/;
// mtllib file_reference
const _material_library_pattern = /^mtllib /;
// usemtl material_name
const _material_use_pattern = /^usemtl /;
// usemap map_name
const _map_use_pattern = /^usemap /;
const _face_vertex_data_separator_pattern = /\s+/;

const _vA = new Vector3();
const _vB = new Vector3();
const _vC = new Vector3();

const _ab = new Vector3();
const _cb = new Vector3();

const _color = new Color();

function ParserState() {
	const state = {
		objects: [],
		object: {},
		vertices: [],
		normals: [],
		colors: [],
		uvs: [],
		materials: {},
		materialLibraries: [],
		startObject: function ( name, fromDeclaration ) {
			// If the current object (initial from reset) is not from a g/o declaration in the parsed
			// file. We need to use it for the first parsed g/o to keep things in sync.
			if ( this.object && this.object.fromDeclaration === false ) {
				this.object.name = name;
				this.object.fromDeclaration = ( fromDeclaration !== false );
				return;
			}
			const previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );
			if ( this.object && typeof this.object._finalize === 'function' ) this.object._finalize( true );
			this.object = {
				name: name || '',
				fromDeclaration: ( fromDeclaration !== false ),
				geometry: {
					vertices: [],
					normals: [],
					colors: [],
					uvs: [],
					hasUVIndices: false
				},
				materials: [],
				smooth: true,
				startMaterial: function ( name, libraries ) {
					const previous = this._finalize( false );
					// New usemtl declaration overwrites an inherited material, except if faces were declared
					// after the material, then it must be preserved for proper MultiMaterial continuation.
					if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {
						this.materials.splice( previous.index, 1 );
					}
					const material = {
						index: this.materials.length,
						name: name || '',
						mtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
						smooth: ( previous !== undefined ? previous.smooth : this.smooth ),
						groupStart: ( previous !== undefined ? previous.groupEnd : 0 ),
						groupEnd: - 1,
						groupCount: - 1,
						inherited: false,
						clone: function ( index ) {
							const cloned = {
								index: ( typeof index === 'number' ? index : this.index ),
								name: this.name,
								mtllib: this.mtllib,
								smooth: this.smooth,
								groupStart: 0,
								groupEnd: - 1,
								groupCount: - 1,
								inherited: false
							};
							cloned.clone = this.clone.bind( cloned );
							return cloned;
						}
					};
					this.materials.push( material );
					return material;
				},
				currentMaterial: function () {
					if ( this.materials.length > 0 ) {
						return this.materials[ this.materials.length - 1 ];
					}
					return undefined;
				},
				_finalize: function ( end ) {
					const lastMultiMaterial = this.currentMaterial();
					if ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {
						lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
						lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
						lastMultiMaterial.inherited = false;
					}
					// Ignore objects tail materials if no face declarations followed them before a new o/g started.
					if ( end && this.materials.length > 1 ) {
						for ( let mi = this.materials.length - 1; mi >= 0; mi -- ) {
							if ( this.materials[ mi ].groupCount <= 0 ) {
								this.materials.splice( mi, 1 );
							}
						}
					}
					// Guarantee at least one empty material, this makes the creation later more straight forward.
					if ( end && this.materials.length === 0 ) {
						this.materials.push( {
							name: '',
							smooth: this.smooth
						} );
					}
					return lastMultiMaterial;
				}
			};
			// Inherit previous objects material.
			// Spec tells us that a declared material must be set to all objects until a new material is declared.
			// If a usemtl declaration is encountered while this new object is being parsed, it will
			// overwrite the inherited material. Exception being that there was already face declarations
			// to the inherited material, then it will be preserved for proper MultiMaterial continuation.
			if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {
				const declared = previousMaterial.clone( 0 );
				declared.inherited = true;
				this.object.materials.push( declared );
			}
			this.objects.push( this.object );
		},
		finalize: function () {
			if ( this.object && typeof this.object._finalize === 'function' ) this.object._finalize( true );
		},
		parseVertexIndex: function ( value, len ) {
			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;
		},
		parseNormalIndex: function ( value, len ) {
			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;
		},
		parseUVIndex: function ( value, len ) {
			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;
		},
		addVertex: function ( a, b, c ) {
			const src = this.vertices;
			const dst = this.object.geometry.vertices;
			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );
		},
		addVertexPoint: function ( a ) {
			const src = this.vertices;
			const dst = this.object.geometry.vertices;
			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
		},
		addVertexLine: function ( a ) {
			const src = this.vertices;
			const dst = this.object.geometry.vertices;
			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
		},
		addNormal: function ( a, b, c ) {
			const src = this.normals;
			const dst = this.object.geometry.normals;
			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );
		},
		addFaceNormal: function ( a, b, c ) {
			const src = this.vertices;
			const dst = this.object.geometry.normals;
			_vA.fromArray( src, a );
			_vB.fromArray( src, b );
			_vC.fromArray( src, c );
			_cb.subVectors( _vC, _vB );
			_ab.subVectors( _vA, _vB );
			_cb.cross( _ab );
			_cb.normalize();
			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );
		},
		addColor: function ( a, b, c ) {
			const src = this.colors;
			const dst = this.object.geometry.colors;
			if ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			if ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			if ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );
		},
		addUV: function ( a, b, c ) {
			const src = this.uvs;
			const dst = this.object.geometry.uvs;
			dst.push( src[ a + 0 ], src[ a + 1 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ] );
		},
		addDefaultUV: function () {
			const dst = this.object.geometry.uvs;
			dst.push( 0, 0 );
			dst.push( 0, 0 );
			dst.push( 0, 0 );
		},
		addUVLine: function ( a ) {
			const src = this.uvs;
			const dst = this.object.geometry.uvs;
			dst.push( src[ a + 0 ], src[ a + 1 ] );
		},
		addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {
			const vLen = this.vertices.length;
			let ia = this.parseVertexIndex( a, vLen );
			let ib = this.parseVertexIndex( b, vLen );
			let ic = this.parseVertexIndex( c, vLen );
			this.addVertex( ia, ib, ic );
			this.addColor( ia, ib, ic );
			// normals
			if ( na !== undefined && na !== '' ) {
				const nLen = this.normals.length;
				ia = this.parseNormalIndex( na, nLen );
				ib = this.parseNormalIndex( nb, nLen );
				ic = this.parseNormalIndex( nc, nLen );
				this.addNormal( ia, ib, ic );
			} else {
				this.addFaceNormal( ia, ib, ic );
			}
			// uvs
			if ( ua !== undefined && ua !== '' ) {
				const uvLen = this.uvs.length;
				ia = this.parseUVIndex( ua, uvLen );
				ib = this.parseUVIndex( ub, uvLen );
				ic = this.parseUVIndex( uc, uvLen );
				this.addUV( ia, ib, ic );
				this.object.geometry.hasUVIndices = true;
			} else {
				// add placeholder values (for inconsistent face definitions)
				this.addDefaultUV();
			}
		},
		addPointGeometry: function ( vertices ) {
			this.object.geometry.type = 'Points';
			const vLen = this.vertices.length;
			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {
				const index = this.parseVertexIndex( vertices[ vi ], vLen );
				this.addVertexPoint( index );
				this.addColor( index );
			}
		},
		addLineGeometry: function ( vertices, uvs ) {
			this.object.geometry.type = 'Line';
			const vLen = this.vertices.length;
			const uvLen = this.uvs.length;
			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {
				this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );
			}
			for ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {
				this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );
			}
		}
	};
	state.startObject( '', false );
	return state;
}
//
class OBJLoader extends Loader {
	constructor( manager ) {
		super( manager );
		this.materials = null;
	}
	load( url, onLoad, onProgress, onError ) {
		const scope = this;
		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {
			try {
				onLoad( scope.parse( text ) );
			} catch ( e ) {
				if ( onError ) onError( e );
				else console.error( e );
				scope.manager.itemError( url );
			}
		}, onProgress, onError );

	}

	setMaterials( materials ) {
		this.materials = materials;
		return this;
	}

	parse( text ) {
		const state = new ParserState();
		if ( text.indexOf( '\r\n' ) !== - 1 ) text = text.replace( /\r\n/g, '\n' );
		if ( text.indexOf( '\\\n' ) !== - 1 ) text = text.replace( /\\\n/g, '' );
		const lines = text.split( '\n' );
		let result = [];
		for ( let i = 0, l = lines.length; i < l; i ++ ) {
			const line = lines[ i ].trimStart();
			if ( line.length === 0 ) continue;
			const lineFirstChar = line.charAt( 0 );
			// @todo invoke passed in handler if any
			if ( lineFirstChar === '#' ) {
				// todo : if line substring (0, 8) = #FFJUMPS : read ff jumps
				continue;
			}
			if ( lineFirstChar === 'v' ) {
				const data = line.split( _face_vertex_data_separator_pattern );
				switch ( data[ 0 ] ) {
					case 'v':
						state.vertices.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] ),
							parseFloat( data[ 3 ] )
						);
						if ( data.length >= 7 ) {
							_color.setRGB(
								parseFloat( data[ 4 ] ),
								parseFloat( data[ 5 ] ),
								parseFloat( data[ 6 ] )
							).convertSRGBToLinear();
							state.colors.push( _color.r, _color.g, _color.b );
						} else state.colors.push( undefined, undefined, undefined );
						break;
					case 'vn':
						state.normals.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] ),
							parseFloat( data[ 3 ] )
						);
						break;
					case 'vt':
						state.uvs.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] )
						);
						break;

				}

			} else if ( lineFirstChar === 'f' ) {
				const lineData = line.slice( 1 ).trim();
				const vertexData = lineData.split( _face_vertex_data_separator_pattern );
				const faceVertices = [];
				// Parse the face vertex data into an easy to work with format
				for ( let j = 0, jl = vertexData.length; j < jl; j ++ ) {
					const vertex = vertexData[ j ];
					if ( vertex.length > 0 ) {
						const vertexParts = vertex.split( '/' );
						faceVertices.push( vertexParts );
					}
				}
				// Draw an edge between the first vertex and all subsequent vertices to form an n-gon
				const v1 = faceVertices[ 0 ];
				for ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {
					const v2 = faceVertices[ j ];
					const v3 = faceVertices[ j + 1 ];
					state.addFace(
						v1[ 0 ], v2[ 0 ], v3[ 0 ],
						v1[ 1 ], v2[ 1 ], v3[ 1 ],
						v1[ 2 ], v2[ 2 ], v3[ 2 ]
					);
				}
			} else if ( ( result = _object_pattern.exec( line ) ) !== null ) state.startObject( ( ' ' + result[ 0 ].slice( 1 ).trim() ).slice( 1 ) );
			else if ( _material_use_pattern.test( line ) ) state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );
			else if ( _material_library_pattern.test( line ) ) state.materialLibraries.push( line.substring( 7 ).trim() );
			else if ( _map_use_pattern.test( line ) ) console.warn( 'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.' );
			else if ( line === '\0' ) continue;
		}
		state.finalize();
		const container = new Group();
		container.materialLibraries = [].concat( state.materialLibraries );
		const hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );
		if ( hasPrimitives === true ) {
			for ( let i = 0, l = state.objects.length; i < l; i ++ ) {
				const object = state.objects[ i ];
				const geometry = object.geometry;
				const materials = object.materials;
				const isLine = ( geometry.type === 'Line' );
				const isPoints = ( geometry.type === 'Points' );
				let hasVertexColors = false;
				// Skip o/g line declarations that did not follow with any faces
				if ( geometry.vertices.length === 0 ) continue;
				const buffergeometry = new BufferGeometry();
				buffergeometry.setAttribute( 'position', new Float32BufferAttribute( geometry.vertices, 3 ) );
				if ( geometry.normals.length > 0 ) {
					buffergeometry.setAttribute( 'normal', new Float32BufferAttribute( geometry.normals, 3 ) );
				}
				if ( geometry.colors.length > 0 ) {
					hasVertexColors = true;
					buffergeometry.setAttribute( 'color', new Float32BufferAttribute( geometry.colors, 3 ) );
				}
				if ( geometry.hasUVIndices === true ) {
					buffergeometry.setAttribute( 'uv', new Float32BufferAttribute( geometry.uvs, 2 ) );
				}
				// Create materials
				const createdMaterials = [];
				for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {
					const sourceMaterial = materials[ mi ];
					const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;
					let material = state.materials[ materialHash ];
					if ( this.materials !== null ) {
						material = this.materials.create( sourceMaterial.name );
						// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
						if ( isLine && material && ! ( material instanceof LineBasicMaterial ) ) {
							const materialLine = new LineBasicMaterial();
							Material.prototype.copy.call( materialLine, material );
							materialLine.color.copy( material.color );
							material = materialLine;
						} else if ( isPoints && material && ! ( material instanceof PointsMaterial ) ) {
							const materialPoints = new PointsMaterial( { size: 10, sizeAttenuation: false } );
							Material.prototype.copy.call( materialPoints, material );
							materialPoints.color.copy( material.color );
							materialPoints.map = material.map;
							material = materialPoints;
						}
					}
					if ( material === undefined ) {
						if ( isLine ) {
							material = new LineBasicMaterial();
						} else if ( isPoints ) {
							material = new PointsMaterial( { size: 1, sizeAttenuation: false } );
						} else {
							material = new MeshPhongMaterial();
						}
						material.name = sourceMaterial.name;
						material.flatShading = sourceMaterial.smooth ? false : true;
						material.vertexColors = hasVertexColors;
						state.materials[ materialHash ] = material;
					}
					createdMaterials.push( material );
				}
				// Create mesh
				let mesh;
				if ( createdMaterials.length > 1 ) {
					for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {
						const sourceMaterial = materials[ mi ];
						buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );
					}
					if ( isLine ) {
						mesh = new LineSegments( buffergeometry, createdMaterials );
					} else if ( isPoints ) {
						mesh = new Points( buffergeometry, createdMaterials );
					} else {
						mesh = new THREE.Mesh( buffergeometry, createdMaterials );
					}
				} else {
					if ( isLine ) {
						mesh = new LineSegments( buffergeometry, createdMaterials[ 0 ] );
					} else if ( isPoints ) {
						mesh = new Points( buffergeometry, createdMaterials[ 0 ] );
					} else {
						mesh = new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] );
					}
				}
				mesh.name = object.name;
				container.add( mesh );
			}
		} else {
			// if there is only the default parser state object with no geometry data, interpret data as point cloud
			if ( state.vertices.length > 0 ) {
				const material = new PointsMaterial( { size: 1, sizeAttenuation: false } );
				const buffergeometry = new BufferGeometry();
				buffergeometry.setAttribute( 'position', new Float32BufferAttribute( state.vertices, 3 ) );
				if ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {
					buffergeometry.setAttribute( 'color', new Float32BufferAttribute( state.colors, 3 ) );
					material.vertexColors = true;
				}
				const points = new Points( buffergeometry, material );
				container.add( points );
			}
		}
		return container;
	}
}
 function initCamera(scene)
{
    scene.camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 2000 );
    //scene.camera.position.z = 25;
    const pointLight = new THREE.PointLight( 0xffffff, 0.8 );
    scene.camera.add( pointLight );
    scene.scene.add( scene.camera );
} 

 function initLighting(scene)
{
    const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
    hemiLight.position.set( 0, 20, 0 );
    scene.env.add( hemiLight );

    const dirLight = new THREE.DirectionalLight( 0xffffff );
    dirLight.position.set( 3, 10, 10 );
    dirLight.castShadow = true;
    dirLight.shadow.camera.top = 2;
    dirLight.shadow.camera.bottom = - 2;
    dirLight.shadow.camera.left = - 2;
    dirLight.shadow.camera.right = 2;
    dirLight.shadow.camera.near = 0.1;
    dirLight.shadow.camera.far = 40;
    scene.env.add( dirLight );
    
}

 function initRenderer(scene)
{
    scene.renderer = new THREE.WebGLRenderer({ antialias: true});
    scene.renderer.setPixelRatio( window.devicePixelRatio );
    scene.renderer.setSize( window.innerWidth, window.innerHeight );
    scene.container.appendChild( scene.renderer.domElement );
}

 function initControls(scene)
{
    scene.controls = new ORBITCONTROL.OrbitControls( scene.camera, scene.renderer.domElement );
    scene.controls.zoomSpeed = 3
    scene.controls.target.set( 0, 0, 0 ); 
    scene.controls.update();
}

function initGround(scene)
{
    const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 1000, 1000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
    mesh.rotation.x = - Math.PI / 2;
    mesh.receiveShadow = true;
    scene.env.add( mesh );
    
    scene.scene.background = new THREE.Color( 0xa0a0a0 );
    scene.scene.fog = new THREE.Fog( 0xa0a0a0, 10, 500 );
}


class DisplayOptions {
    bIsShowEdges = true;
    bIsShowVerts = true;
    bSinguEdit = false;
    pointWidth = 1;
}

class GuiPanel {
    constructor(scene) {
        this.gui = new LILGUI.GUI();
        this.displayOptions = new DisplayOptions()
        this.display = undefined;
        this.actions = undefined;
        this.scene = scene
    }

    init() {
		/*
        this.display = this.gui.addFolder('display');
        const p_disp = { 'show edges': true, 'show points': true, 'point width': 0.1, 'singu edit' : false };
        this.display.add(p_disp, 'show edges').onChange(((val) => {
            this.displayOptions.bIsShowEdges = val;
            //this.scene.mesh.updateDisplay(this.displayOptions)
        }).bind(this));
        this.display.add(p_disp, 'show points').onChange(((val) => {
            this.displayOptions.bIsShowVerts = val;
            //this.scene.mesh.updateDisplay(this.displayOptions)
        }).bind(this));
        this.display.add(p_disp, 'point width', 0.01, 0.3, 0.01).onChange(((val)=> {
            this.displayOptions.pointWidth = val;
            //this.scene.mesh.updateDisplay(this.displayOptions)
        }).bind(this));
        this.display.add(p_disp, 'singu edit').onChange(((val) => {
            this.displayOptions.bSinguEdit = val;
        }).bind(this));*/
		/*this.gui.add( obj, 'Select : ', [ 'Input', 'FF', 'Param', 'Quantiz', 'Quads' ] ) .onChange( function( v ) {
			if(v == 'Input') { scene.mesh.state = 0; }
			if(v == 'FF') { scene.mesh.state = 0; }
			if(v == 'Param') { scene.mesh.state = 0; }
			if(v == 'Quantiz') { scene.mesh.state = 0; }
			if(v == 'Quads') { scene.mesh.state = 0; }
			display();
		} );*/
		/*const sel_actions = {
			'Input': (()=> { scene.mesh.state = 0; display(); }),
			'FF': (()=> { scene.mesh.state = 1; display(); }),
            'Param': (()=> {  scene.mesh.state = 2; display(); }),
			'Quantiz': (()=> { scene.mesh.state = 3; display();  }),
            'Quads': (()=> { scene.mesh.state = 4; display(); })
		}*/
		/*var whatever = {}
		this.gui.add(whatever, 'Select display : ', [ 'Input', 'FF', 'Param', 'Quantiz', 'Quads' ]).onChange( function( v ) {
			console.log(whatever);
			if(v == 'Input') { scene.mesh.state = 0; }
			if(v == 'FF') { scene.mesh.state = 1; }
			if(v == 'Param') { scene.mesh.state = 2; }
			if(v == 'Quantiz') { scene.mesh.state = 3; }
			if(v == 'Quads') { scene.mesh.state = 4; }
			display();
		} );
        this.actions = this.gui.addFolder('actions');
        const p_actions = { 
            'Compute FrameField': (()=> { scene.mesh.strFF = Module.computeFF(scene.mesh.strInputMesh); scene.mesh.state = 1; display(); }),
            'Compute Param': (()=> {  if(scene.mesh.state != 1 || !scene.mesh.strFF) return; scene.mesh.strParam = Module.computeParam(scene.mesh.strFF); scene.mesh.state = 2; display();}),
			'Compute Quantization': (()=> { if(scene.mesh.state != 2 || !scene.mesh.strParam) return; scene.mesh.strQuantiz = Module.computeQuantization(scene.mesh.strParam); scene.mesh.state = 3; display(); }),
            'Compute Quads': (()=> { if(scene.mesh.state != 3 || !scene.mesh.strQuantiz) return; scene.mesh.strQuads = Module.computeQuads(scene.mesh.strQuantiz); scene.mesh.state = 4; display();}), 
			'Smooth current': (()=> { console.log("FRAMEFIELD"); scene.mesh.strFF = Module.computeFF(scene.mesh.strInputMesh); display(); }),
            'Download': (()=> {  download();}) 
		};
        this.actions.add(p_actions, 'Compute FrameField');
        this.actions.add(p_actions, 'Compute Param');
		this.actions.add(p_actions, 'Compute Quantization');
		this.actions.add(p_actions, 'Compute Quads');
		this.actions.add(p_actions, 'Download');
		*/
		//this.inpactions = this.gui.addFolder('Actions');
		{ 
			const p_actions = { 
				/*'Compute all quad meshing steps':  (()=> 
				{ 
					const loadingSpinner = document.getElementById("loading-spinner");
					loadingSpinner.style.display = "block";
			
					if(!scene.mesh.strInputMesh) return; 
					setTimeout(() => {
					scene.mesh.strFF = Module.computeFF(scene.mesh.strInputMesh); //scene.mesh.state = 1; display(); 
					scene.mesh.strParam = Module.computeParam(scene.mesh.strFF); //scene.mesh.state = 2; display();
					scene.mesh.strQuantiz = Module.computeQuantization(scene.mesh.strParam); //scene.mesh.state = 3; display();
					scene.mesh.strQuads = Module.computeQuads(scene.mesh.strQuantiz); scene.mesh.state = 4; display(); 
					loadingSpinner.style.display = "none";
					}, 0);
				}
				'Compute all quad meshing steps':  (() => {
                    const loadingSpinner = document.getElementById("loading-spinner");
                    loadingSpinner.style.display = "block";

                    if (!scene.mesh.strInputMesh) return;

                    const worker = new Worker('wasm_worker.js');

                    worker.postMessage({
                        strInputMesh: scene.mesh.strInputMesh
                    });

                    worker.onmessage = function(event) {
                        const { strFF, strParam, strQuantiz, strQuads } = event.data;
                        scene.mesh.strFF = strFF;
                        scene.mesh.strParam = strParam;
                        scene.mesh.strQuantiz = strQuantiz;
                        scene.mesh.strQuads = strQuads;
                        scene.mesh.state = 4;
                        display();
                        loadingSpinner.style.display = "none";
                    }
                }),*/
				'Display triangular mesh input': (()=> { if(!scene.mesh.strInputMesh) return; scene.mesh.state = 0; display(); }),
				'Download displayed mesh': (()=> {  download();}) 
			}; 
			//this.gui.add(p_actions, 'Compute all quad meshing steps');
			this.gui.add(p_actions, 'Display triangular mesh input');
			this.gui.add(p_actions, 'Download displayed mesh');
		}
		this.ffactions = this.gui.addFolder('Frame Field');
		{ 
			const p_actions = { 
				'Compute from input mesh': (()=> { 
					if(!scene.mesh.strInputMesh) return; 
					loadingSpinner.style.display = "block";
					worker.postMessage({command: "computeFF", contents: scene.mesh.strInputMesh});
					//scene.mesh.strFF = Module.computeFF(scene.mesh.strInputMesh); 
					//scene.mesh.state = 1; display(); 
				}),
				'Compute without features' : (()=> { 
					if(!scene.mesh.strInputMesh) return; 
					loadingSpinner.style.display = "block";
					var entete = '#NOFE'; 
					worker.postMessage({command: "computeFF", contents: entete.concat('\n', scene.mesh.strInputMesh)});
					//scene.mesh.state = 1; display(); 
				}),
				'Display only': (()=> { if(!scene.mesh.strFF) return; scene.mesh.state = 1; display(); })
			}; 
			this.ffactions.add(p_actions, 'Compute from input mesh');
			this.ffactions.add(p_actions, 'Compute without features');
			this.ffactions.add(p_actions, 'Display only');
		}
		this.sfactions = this.gui.addFolder('Seamless parameterization');
		this.sfoptions = {'Texrepeat':1}
		{ 
			const p_actions = { 
				'Compute from framefield': (()=> {  
					if(!scene.mesh.strFF) return; 
					loadingSpinner.style.display = "block";
					worker.postMessage({command: "computeParam", contents: scene.mesh.strFF});
					//scene.mesh.state = 2; display();
				}),
				'Compute without features': (()=> {  
					if(!scene.mesh.strFF) return;
					loadingSpinner.style.display = "block"; 
					var entete = '#NOFE'; 
					worker.postMessage({command: "computeParam", contents: entete.concat('\n', scene.mesh.strFF)}); 
				}),
				'Display only': (()=> { if(!scene.mesh.strParam) return; scene.mesh.state = 2; display(); })
			}; 
			this.sfactions.add(p_actions, 'Compute from framefield');
			this.sfactions.add(p_actions, 'Compute without features');
			this.sfactions.add(p_actions, 'Display only');
			this.sfactions.add( this.sfoptions, 'Texrepeat' ).onFinishChange( value => {
				if(scene.mesh.state == 2){
					scene.mesh.mesh.texture.repeat.set(value, value)
					scene.mesh.mesh.material.needsUpdate = true;
				}
			} );
		}
		this.sfqactions = this.gui.addFolder('Quantized parameterization');
		{ 
			const p_actions = { 
				'Compute from seamless map': (()=> { 
					if(!scene.mesh.strParam) return; 
					loadingSpinner.style.display = "block";
					var entete = '#TEXREPEAT:' ; 
					var input = entete.concat(this.sfoptions.Texrepeat.toString(),'\n', scene.mesh.strParam);
					worker.postMessage({command: "computeQuantization", contents: input}); 
				}),
				'Display only': (()=> { if(!scene.mesh.strQuantiz) return; scene.mesh.state = 3; display(); })
			}; 
			this.sfqactions.add(p_actions, 'Compute from seamless map');
			this.sfqactions.add(p_actions, 'Display only');
		}
		this.qactions = this.gui.addFolder('Quad mesh extraction');
		{ 
			const p_actions = { 
				'Compute from quantized map': (()=> { 
					if(!scene.mesh.strQuantiz) return; 
					loadingSpinner.style.display = "block";
					worker.postMessage({command: "computeQuads", contents: scene.mesh.strQuantiz}); 
				}), 
				'Display only': (()=> {  if(!scene.mesh.strQuads) return; scene.mesh.state = 4; display(); })
			}; 
			this.qactions.add(p_actions, 'Compute from quantized map');
			this.qactions.add(p_actions, 'Display only');
		}
    }
};



worker.onmessage = function(e) {
	console.log("Main receive message: " , e.data.command)
	loadingSpinner.style.display = "none";
	if (e.data.command === "meshLoaded") {
		console.log("Mesh loaded");
		const strInputMesh = e.data.contents
		scene.mesh.strInputMesh = ""; 
		scene.mesh.strFF = ""; 
		scene.mesh.strParam = ""; 
		scene.mesh.strQuantiz = ""; 
		scene.mesh.strQuads = "";

		scene.mesh.strInputMesh = strInputMesh;
		if(scene.mesh.strInputMesh[7] == '0') scene.mesh.state = 0
		if(scene.mesh.strInputMesh[7] == '1') {scene.mesh.strFF = scene.mesh.strInputMesh; scene.mesh.state = 1;}
		if(scene.mesh.strInputMesh[7] == '2') {scene.mesh.strParam = scene.mesh.strInputMesh; scene.mesh.state = 2;}
		if(scene.mesh.strInputMesh[7] == '3') {scene.mesh.strQuantiz = scene.mesh.strInputMesh; scene.mesh.state = 3;}
		if(scene.mesh.strInputMesh[7] == '4') {scene.mesh.strQuads = scene.mesh.strInputMesh; scene.mesh.state = 4;}
		
		reset_camera_position();
		display(scene.mesh.strInputMesh);
	}
	if (e.data.command === "computeFF") {
		console.log("FF loaded");
		scene.mesh.strFF = e.data.contents;
		scene.mesh.state = 1; display(); 
	}
	if (e.data.command === "computeParam") {
		console.log("Param loaded");
		scene.mesh.strParam = e.data.contents;
		scene.mesh.state = 2; display(); 
	}
	if (e.data.command === "computeQuantization") {
		console.log("Quantization loaded");
		scene.mesh.strQuantiz = e.data.contents;
		scene.mesh.state = 3; display(); 
	}
	if (e.data.command === "computeQuads") {
		console.log("Quads loaded");
		scene.mesh.strQuads = e.data.contents;
		scene.mesh.state = 4; display(); 
	}
};

function readFile(file) {
    const reader = new FileReader();
    reader.addEventListener('load', (event) => {

		worker.postMessage({command: "loadMesh", contents: event.target.result});

    });
    reader.readAsText(file);
}
  function display(){
	var content;
	if(scene.mesh.state == 0) content = scene.mesh.strInputMesh 
	if(scene.mesh.state == 1) content = scene.mesh.strFF
	if(scene.mesh.state == 2) content = scene.mesh.strParam 
	if(scene.mesh.state == 3) content = scene.mesh.strQuantiz
	if(scene.mesh.state == 4) content = scene.mesh.strQuads
	if(!content) return
    var blob = new Blob([content], {
        type: "text/plain;charset=utf-8"
    });
    var a=document.createElement("a");
    document.body.appendChild(a);
    a.style="display:none";
    var url=window.URL.createObjectURL(blob);
	scene.mesh.filePath = url
	if(scene.mesh.object) scene.scene.remove(scene.mesh.object)
	scene.mesh.loadMesh()
	scene.scene.add(scene.mesh.object)
    window.URL.revokeObjectURL(url);
    //saveAs(blob, filename);
  }
  function download(){//(content){
	var content;
	if(scene.mesh.state == 0) content = scene.mesh.strInputMesh 
	if(scene.mesh.state == 1) content = scene.mesh.strFF
	if(scene.mesh.state == 2) content = scene.mesh.strParam 
	if(scene.mesh.state == 3) content = scene.mesh.strQuantiz
	if(scene.mesh.state == 4) content = scene.mesh.strQuads
    var blob = new Blob([content], {
        type: "text/plain;charset=utf-8"
    });
    var a=document.createElement("a");
    document.body.appendChild(a);
    a.style="display:none";
    var url=window.URL.createObjectURL(blob);
    a.href=url;
    a.download="out.obj";
    a.click();
    window.URL.revokeObjectURL(url);
    //saveAs(blob, filename);
  }

class Scene {
  constructor() {
    this.container = document.createElement('div');
    this.camera = null
    this.renderer = null
    this.env = new THREE.Group()
    this.scene = new THREE.Scene
    this.mesh = new TmpMesh();
    this.raycaster = new THREE.Raycaster();
    this.raycaster.params.Line.threshold = 0.000001;
    this.raycaster.params.Points.threshold = 0.05;
    this.pointer = new THREE.Vector2(0, 0);
    this.selVert = null;
	this.controls = null;
	this.gui = null;
    this.init();
  }

  init() {
    document.body.appendChild(this.container);
    initCamera(this);
    initLighting(this);
    initCamera(this);
    initRenderer(this);
    initGround(this);
    initControls(this);
    this.initEventListeners();
    //this.mesh.loadMesh(this.camera);
    //this.scene.add(this.mesh.object)
    this.gui = new GuiPanel(this)
    this.gui.init()
	
  }

  onPointerMove( event ) {
    this.pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    this.pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
  }

  
  initEventListeners() {
    window.addEventListener('resize', this.onWindowResize.bind(this));
    document.addEventListener( 'pointermove', this.onPointerMove.bind(this) );
    document.addEventListener('keyup', this.onDocumentKeyDown.bind(this));
    const fileInput = document.getElementById('file-selector');
    /*const fileSelector = document.getElementById('file-selector');
      fileSelector.addEventListener('change', (event) => {
        const fileList = event.target.files;
        for (let i = 0; i < fileList.length; i++) { 
          var file=fileList[i];
          readFile(file);
        }
      });*/
      
    fileInput.onchange = (() => {
      const selectedFile = fileInput.files[0];
	  loadingSpinner.style.display = "block";
      readFile(selectedFile);
      /*this.mesh.filePath = URL.createObjectURL(selectedFile)
      if(this.mesh.object) this.scene.remove(this.mesh.object)
      this.mesh.loadMesh(this.camera)
      this.scene.add(this.mesh.object)*/
      //this.scene.add(this.mesh.pointsCloud)
    }).bind(this)
  }

  onDocumentKeyDown(event) {
	/*
    switch (event.keyCode) {
      case 68:
        if(this.selVert !== null) {
          const attr = this.mesh.pointsCloud.geometry.attributes;
          attr.singu_valence.array[ this.selVert ] --;
          //if(attr.singu_valence.array[ this.selVert ] < 3)  attr.singu_valence.array[ this.selVert ] = 3;
          attr.singu_valence.needsUpdate = true;
          console.log("Valence : ", attr.singu_valence.array[ this.selVert ]);
          break;
        }
        break;
      case 70:
        if(this.selVert !== null) {
          const attr = this.mesh.pointsCloud.geometry.attributes;
          attr.singu_valence.array[ this.selVert ] ++;
          //if(attr.singu_valence.array[ this.selVert ] > 5)  attr.singu_valence.array[ this.selVert ] = 5;
          attr.singu_valence.needsUpdate = true;
          console.log("Valence : ", attr.singu_valence.array[ this.selVert ]);
          break;
        }
        break;
    }*/
  };

  onWindowResize() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }

  animate() {
    requestAnimationFrame(this.animate.bind(this));
    this.render();
  }
  

  render() {
	this.controls.update()
    this.renderer.render(this.scene, this.camera);
    this.raycaster.setFromCamera( this.pointer, this.camera );
    
  }
}

function reset_camera_position(){
	scene.controls.reset();
	//scene.controls.enableDamping = true;
	scene.controls.target.set(0, 0, 0);
	scene.camera.position.set( 0, 0, 10 );
	scene.controls.update();
}
class TmpMesh {
    constructor(path = '') {
		this.strInputMesh = ""
		this.strFF = ""
		this.strParam = ""
		this.strQuantiz = ""
		this.strQuads = ""

		this.state = 0

        this.filePath = path
        this.object = new THREE.Group()
        this.pointGroup = new THREE.Group()
        this.mesh = null
    }
    loadMesh() {
        //if(this.object) camera.remove(this.object)
        //camera.position.fromArray([0, 0, 0]);
        
        this.object = new THREE.Group()
		const loader = new OBJLoader();

		// load a resource
		loader.load(
			// resource URL
			this.filePath,
			// called when resource is loaded
			function ( obj ) {

				obj.name = "mesh"
				this.mesh = obj.children[0]
				var texture = new THREE.Texture();
				if(this.state == 1 || this.state == 2 || this.state == 3) {
					var image = new Image();
					if(this.state == 3) image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAACTSURBVHhe7ZsxCsAwDMSc/v/Pbku19A2SIGi24MacmdnnabmwFn2A3wR2HWs45z37owlgLQXAWgqAtRQAaykA1lIArKUAWEsBsJYCYC0FwFoKgLUUAGspANZSAKylAFhLAbCWAmAtBcBaCoC1FABrKQDWUgCspQBYSwGwlgJgLQXAWgqAtRQAa9EH6PM01iIPMHMDoP0Ge8GtP5UAAAAASUVORK5CYII=';
					else if(this.state == 1) image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAC3SURBVHhe7ZqxEcIwEMAcRoAWOth/IOighRVCArqMkEbSnU9urfuksacxxrwsLQesZZuAed53ED6XG7s/x+ed3T5M03r0JqAABcBaCoC1FABrKQDWUgCspQBYSwGwlgJgLQXAWgqAtRQAaykA1qIPsN0Nvs/XVRpOr8fPfQJYS/+AZfU+wEwBsJYCYC0FwFoKgLUUAGspANZSAKylAFhLAbCWAmAtBcBaCoC1FABr2e4GrcgnYIwvT/kUd8SZf6MAAAAASUVORK5CYII=';
					else image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH4AAAB+CAIAAABtQTLfAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFkSURBVHhe7dKhUQRBFEXRHuKYLAiAlqA3ztVYAoAsJhBMi67CTnHNOeY/fesfc8zxx/O81uIOj+tca/OyLv9O+oz0Gekz0meOt/fvNTdfn69rcYf58bPWxtdnpM9In5E+I31G+oz0Gekz0mekz0ifkT4jfUb6jPQZ6TPSZ6TPSJ+RPiN9RvqM9BnpM9JnpM9In5E+I31G+oz0Gekz0mekz0ifkT4jfUb6jPQZ6TPSZ6TPSJ+RPiN9RvqM9BnpM9JnpM9In5E+I31G+oz0Gekz0mekz0ifkT4jfUb6jPQZ6TPSZ6TPSJ+RPiN9RvqM9BnpM9JnpM9In5E+I31G+oz0Gekz0mekz0ifkT4jfUb6jPQZ6TPSZ6TPSJ+RPiN9RvqM9BnpM9JnpM9In5E+I31G+oz0Gekz0mekz0ifkT4jfUb6jPQZ6TPHHHPNzfO81uIOj+tca+PrM9JnpM9In5E+I31kjF973wxNw84+fQAAAABJRU5ErkJggg==';
					texture.image = image;
					texture.wrapS = THREE.RepeatWrapping;
					texture.wrapT = THREE.RepeatWrapping;
					texture.repeat.set( 1, 1 );
					this.mesh.texture = texture
					//console.log(this.mesh.geometry.getAttribute('uv'))
					this.mesh.material = new THREE.MeshLambertMaterial( {  
						transparent: true,
						map: texture
					} );
					image.onload = function() {
						texture.needsUpdate = true;
					};
				}
				else {
					this.mesh.material = new THREE.MeshBasicMaterial( { color: 0xcccccc } );
					this.mesh.material.transparent = false; this.mesh.material.side = THREE.DoubleSide;
				}
				this.mesh.geometry.computeBoundingBox();
				this.mesh.geometry.center()

				let bbox = this.mesh.geometry.boundingBox;
				let max_scale = Math.max(Math.max(bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y), bbox.max.z - bbox.min.z)
				this.mesh.scale.set(10./max_scale,10./max_scale,10./max_scale)
				//scene.controls.reset();
				//scene.controls.enableDamping = true;
				//scene.controls.target.set(0, 0, 0);
				//scene.camera.position.set( 0, 0, 10 );
				//scene.controls.update();
				this.object.add(this.mesh);
				if(this.state == 0 || this.state == 4){
					if(this.state == 4) this.wireframe = new THREE.LineSegments(new QuadWireframeGeometry(this.mesh.geometry), new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
					else this.wireframe = new THREE.LineSegments(new WireframeGeometry(this.mesh.geometry), new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
					//this.wireframe = new THREE.LineSegments(new WireframeGeometry(this.mesh.geometry), new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
					this.wireframe.name = "wireframe"
					this.wireframe.scale.set(10./max_scale,10./max_scale,10./max_scale)
					//this.recenter_and_rescale(this.wireframe)
					this.object.add(this.wireframe)
				}

			}.bind(this),
			// called when loading is in progresses
			function ( xhr ) {
				//console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
			},
			// called when loading has errors
			function ( error ) {
				console.log( 'An error happened' );
				console.log(error);
			}
		);
    }
}

class QuadWireframeGeometry extends BufferGeometry {
	constructor( geometry = null ) {
		super();
		this.type = 'WireframeGeometry';
		this.parameters = {
			geometry: geometry
		};
		if ( geometry !== null ) {
			// buffer
			const vertices = [];
			const edges = new Set();
			// helper variables
			const start = new Vector3();
			const end = new Vector3();
			if ( geometry.index !== null ) {
				// indexed BufferGeometry
				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;
				if ( groups.length === 0 ) {
					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];
				}
				// create a data structure that contains all edges without duplicates
				for ( let o = 0, ol = groups.length; o < ol; ++ o ) {
					const group = groups[ o ];
					const groupStart = group.start;
					const groupCount = group.count;
					for ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {
						//jst = 0; jend=1; 
						//if(i%6 >= 3) {jst = 1; jend = 3;}
						for ( let j = 0; j < 3; j ++ ) {
							const index1 = indices.getX( i + j );
							const index2 = indices.getX( i + ( j + 1 ) % 3 );
							start.fromBufferAttribute( position, index1 );
							end.fromBufferAttribute( position, index2 );
							if ( isUniqueEdge( start, end, edges ) === true ) {
								vertices.push( start.x, start.y, start.z );
								vertices.push( end.x, end.y, end.z );
							}
						}
					}
				}
			} else {
				// non-indexed BufferGeometry
				const position = geometry.attributes.position;
				for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {
					var jst = 0; var jend=2; 
					if(i%2 == 1) {jst = 1; jend = 3;}
					for ( let j = jst; j < jend; j ++ ) {
						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
						const index1 = 3 * i + j;
						const index2 = 3 * i + ( ( j + 1 ) % 3 );
						start.fromBufferAttribute( position, index1 );
						end.fromBufferAttribute( position, index2 );
						if ( isUniqueEdge( start, end, edges ) === true ) {
							vertices.push( start.x, start.y, start.z );
							vertices.push( end.x, end.y, end.z );
						}
					}
				}
			}
			// build geometry
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		}
	}
}

function isUniqueEdge( start, end, edges ) {
	const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
	const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge
	if ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {
		return false;
	} else {
		edges.add( hash1 );
		edges.add( hash2 );
		return true;
	}
}

let scene = new Scene();

scene.animate();</script>
  </body>
</html>